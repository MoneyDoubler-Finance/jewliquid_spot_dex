import{P as e,K as t,V as r}from"./chunk-DdBifORb.js";import{r as a,b as s}from"./chunk-C47o46mc.js";import{a as n}from"./chunk-XUcrMwUP.js";
/*! js-cookie v3.0.5 | MIT */function o(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var a in r)e[a]=r[a]}return e}var i=function e(t,r){function a(e,a,s){if("undefined"!=typeof document){"number"==typeof(s=o({},r,s)).expires&&(s.expires=new Date(Date.now()+864e5*s.expires)),s.expires&&(s.expires=s.expires.toUTCString()),e=encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape);var n="";for(var i in s)s[i]&&(n+="; "+i,!0!==s[i]&&(n+="="+s[i].split(";")[0]));return document.cookie=e+"="+t.write(a,e)+n}}return Object.create({set:a,get:function(e){if("undefined"!=typeof document&&(!arguments.length||e)){for(var r=document.cookie?document.cookie.split("; "):[],a={},s=0;s<r.length;s++){var n=r[s].split("="),o=n.slice(1).join("=");try{var i=decodeURIComponent(n[0]);if(a[i]=t.read(o,i),e===i)break}catch(c){}}return e?a[e]:a}},remove:function(e,t){a(e,"",o({},t,{expires:-1}))},withAttributes:function(t){return e(this.converter,o({},this.attributes,t))},withConverter:function(t){return e(o({},this.converter,t),this.attributes)}},{attributes:{value:Object.freeze(r)},converter:{value:Object.freeze(t)}})}({read:function(e){return'"'===e[0]&&(e=e.slice(1,-1)),e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent)},write:function(e){return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,decodeURIComponent)}},{path:"/"});const c=n(a()),l=(e,t)=>e.map(e=>e.id===t?{...e,isActive:!e.isActive}:e),d=(e,t)=>e.filter(e=>e.id!==t),u="wallets";let y=null;const p=indexedDB.open("WalletDB",1);p.onerror=()=>{},p.onsuccess=e=>{y=p.result},p.onupgradeneeded=e=>{y=p.result,y.objectStoreNames.contains(u)||y.createObjectStore(u,{keyPath:"id"})};const w="config",h="quickBuyPreferences",f="tradingStrategies",m="user",g="raze-bot-wallet-encryption-key",b="encrypted_wallets",v=e=>{try{return c.AES.encrypt(e,g).toString()}catch(t){throw new Error("Failed to encrypt data")}},S=async()=>{const e=t.generate(),r=e.publicKey.toString(),a=s.encode(e.secretKey);return{id:Date.now(),address:r,privateKey:a,isActive:!1}},T=async e=>{try{if(!e.trim())return{wallet:null,error:"Private key cannot be empty"};let a;try{if(a=s.decode(e),64!==a.length)return{wallet:null,error:"Invalid private key length"}}catch(r){return{wallet:null,error:"Invalid private key format"}}const n=t.fromSecretKey(a).publicKey.toString();return{wallet:{id:Date.now(),address:n,privateKey:e,isActive:!1}}}catch(a){return{wallet:null,error:"Failed to import wallet"}}},k=e=>e.length<8?e:`${e.slice(0,4)}...${e.slice(-4)}`,K=e=>e.label&&e.label.trim()?e.label:k(e.address),B=async(e,t)=>{try{return await navigator.clipboard.writeText(e),t("Copied successfully","success"),!0}catch(r){return!1}},P=()=>{try{return I()}catch(e){return[]}},$=async(t,r,a)=>{try{const s=new e(r),n=new e(a),o=await t.getParsedTokenAccountsByOwner(s,{mint:n},"processed");if(0===o.value.length)return 0;return o.value[0].account.data.parsed.info.tokenAmount.uiAmount||0}catch(s){return 0}},C=async(t,r)=>{try{const a=new e(r);return await t.getBalance(a,"processed")/1e9}catch(a){return 0}},O=async(e,t,r,a,s,n,o)=>{const i=new Map(n||new Map),c=new Map(o||new Map);for(let d=0;d<t.length;d++){const n=t[d];try{const t=await C(e,n.address);if(i.set(n.address,t),a(new Map(i)),r){const t=await $(e,n.address,r);c.set(n.address,t),s(new Map(c))}}catch(l){}d<t.length-1&&await new Promise(e=>setTimeout(e,5))}return{solBalances:i,tokenBalances:c}},A=async(e,t,r,a)=>{const s=new Map;for(let o=0;o<t.length;o++){const r=t[o];try{const t=await C(e,r.address);s.set(r.address,t)}catch(n){}o<t.length-1&&await new Promise(e=>setTimeout(e,10))}return r(s),s},j=async(e,t,r,a)=>{if(!r)return new Map;const s=new Map,n=t.map(async t=>{try{const a=await $(e,t.address,r);s.set(t.address,a)}catch(a){}});return await Promise.all(n),a(s),s},N=(e,t,r,a,s)=>{const n="asc"===t?"desc":"asc";r(n);s([...e].sort((e,t)=>{const r=a.get(e.address)||0,s=a.get(t.address)||0;return"asc"===n?r-s:s-r}))},E=(e,t,r,a,s)=>{const n=new Set;let o=0,i=0;const c=e.filter(e=>{const a=t.get(e.address)||0,s=r.get(e.address)||0;return a<=0&&s<=0?(o++,!1):n.has(e.address)?(i++,!1):(n.add(e.address),!0)});if(o>0||i>0){const e=[];o>0&&e.push(`${o} empty wallet${1===o?"":"s"}`),i>0&&e.push(`${i} duplicate${1===i?"":"s"}`),s(`Removed ${e.join(" and ")}`,"success")}else s("No empty wallets or duplicates found","success");a(c)},F=e=>{try{const t=JSON.stringify(e),r=v(t);if(!y)return localStorage.setItem(b,r),void localStorage.removeItem("wallets");const a=y.transaction(u,"readwrite").objectStore(u);a.clear();const s={id:"encrypted_wallets",data:r};a.add(s),localStorage.setItem(b,r),localStorage.removeItem("wallets")}catch(t){try{const t=JSON.stringify(e),r=v(t);localStorage.setItem(b,r),localStorage.removeItem("wallets")}catch(r){localStorage.setItem("wallets",JSON.stringify(e))}}},I=()=>{try{const t=localStorage.getItem(b);if(t)try{const e=(e=>{try{const t=c.AES.decrypt(e,g).toString(c.enc.Utf8);if(!t)throw new Error("Failed to decrypt data - invalid key or corrupted data");return t}catch(t){throw new Error("Failed to decrypt data")}})(t);return JSON.parse(e)}catch(e){const t=localStorage.getItem("wallets");if(t){const e=JSON.parse(t);return F(e),e}}const r=localStorage.getItem("wallets");if(r){const e=JSON.parse(r);return F(e),e}return[]}catch(t){return[]}},R=e=>{i.set(w,JSON.stringify(e),{expires:30})},x=()=>{const e=i.get(w);if(e)try{const t=JSON.parse(e);return void 0===t.slippageBps&&(t.slippageBps="9900"),void 0===t.bundleMode&&(t.bundleMode="batch"),void 0===t.singleDelay&&(t.singleDelay="200"),void 0===t.batchDelay&&(t.batchDelay="1000"),void 0===t.tradingServerEnabled&&(t.tradingServerEnabled="false"),void 0===t.tradingServerUrl&&(t.tradingServerUrl="localhost:4444"),t}catch(t){return null}return null},M=e=>void 0===e?"0.00":e<1e3?e.toFixed(2):e<1e6?`${(e/1e3).toFixed(1)}K`:e<1e9?`${(e/1e6).toFixed(1)}M`:`${(e/1e9).toFixed(1)}B`,U=e=>{const t=new Blob([e.privateKey],{type:"text/plain"}),r=URL.createObjectURL(t),a=document.createElement("a");a.href=r,a.download=`wallet-${e.address.slice(0,8)}.key`,document.body.appendChild(a),a.click(),document.body.removeChild(a),URL.revokeObjectURL(r)},D=e=>{const t=e.map(e=>`${e.address}\n${e.privateKey}\n\n`).join(""),r=new Blob([t],{type:"text/plain"}),a=URL.createObjectURL(r),s=document.createElement("a");s.href=a,s.download="wallets.txt",document.body.appendChild(s),s.click(),document.body.removeChild(s),URL.revokeObjectURL(a)},J=e=>{i.set(h,JSON.stringify(e),{expires:30})},z=()=>{const e=i.get(h);if(e)try{return JSON.parse(e)}catch(t){return null}return null},L=e=>{i.set(f,JSON.stringify(e),{expires:30})},W=()=>{const e=i.get(f);if(e)try{return JSON.parse(e)}catch(t){return[]}return[]},H=e=>{i.set(m,e,{expires:30})},_=()=>i.get(m)||null,q=Object.freeze(Object.defineProperty({__proto__:null,copyToClipboard:B,createNewWallet:S,deleteWallet:d,downloadAllWallets:D,downloadPrivateKey:U,fetchSolBalance:C,fetchSolBalances:A,fetchTokenBalance:$,fetchTokenBalances:j,fetchWalletBalances:O,formatAddress:k,formatTokenBalance:M,getWalletDisplayName:K,getWallets:P,handleCleanupWallets:E,handleSortWallets:N,importWallet:T,loadConfigFromCookies:x,loadQuickBuyPreferencesFromCookies:z,loadTradingStrategiesFromCookies:W,loadUserFromCookies:_,loadWalletsFromCookies:I,saveConfigToCookies:R,saveQuickBuyPreferencesToCookies:J,saveTradingStrategiesToCookies:L,saveUserToCookies:H,saveWalletsToCookies:F,toggleWallet:l},Symbol.toStringTag,{value:"Module"})),V=async e=>{try{const t=window.tradingServerUrl?.replace(/\/+$/,"")||"",r=await fetch(`${t}/api/transactions/send`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transactions:e})});return(await r.json()).result}catch(t){throw t}},Q=async(e,a)=>{try{const n=a.map(e=>({address:e.address,amount:e.amount})),o=await(async(e,t)=>{try{const r="https://solana.fury.bot",a=await fetch(`${r}/api/wallets/distribute`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sender:e,recipients:t})});if(!a.ok)throw new Error(`HTTP error! Status: ${a.status}`);const s=await a.json();if(!s.success)throw new Error(s.error||"Failed to get partially signed transactions");return s.transactions}catch(r){throw r}})(e.address,n),i=t.fromSecretKey(s.decode(e.privateKey)),c=new Map;a.forEach(e=>{const r=t.fromSecretKey(s.decode(e.privateKey));c.set(r.publicKey.toBase58(),r)});const l=((e,t,a)=>{try{return e.map(e=>{const n=s.decode(e),o=r.deserialize(n),i=o.message,c=[];c.push(t);for(const t of i.staticAccountKeys){const e=t.toBase58();a.has(e)&&c.push(a.get(e))}return o.sign(c),s.encode(o.serialize())})}catch(n){throw n}})(o,i,c),d=[{transactions:l}];let u=[];for(let e=0;e<d.length;e++){const t=d[e],r=await V(t.transactions);u.push(r),e<d.length-1&&await new Promise(e=>setTimeout(e,500))}return{success:!0,result:u}}catch(n){return{success:!1,error:n.message}}},G=(e,t,r)=>{if(!e.address||!e.privateKey)return{valid:!1,error:"Invalid sender wallet"};if(!t.length)return{valid:!1,error:"No recipient wallets"};for(const s of t){if(!s.address||!s.privateKey||!s.amount)return{valid:!1,error:"Invalid recipient wallet data"};if(isNaN(parseFloat(s.amount))||parseFloat(s.amount)<=0)return{valid:!1,error:"Invalid amount: "+s.amount}}const a=t.reduce((e,t)=>e+parseFloat(t.amount),0);return a+.01>r?{valid:!1,error:`Insufficient balance. Need at least ${a+.01} SOL, but have ${r} SOL`}:{valid:!0}},X=async(e,t)=>{try{if(0===t.length)return{success:!0,results:[]};if(t.length<=3){const r=await Q(e,t);return{success:r.success,results:r.success?[r.result]:[],error:r.error}}const r=3,a=[];for(let e=0;e<t.length;e+=r)a.push(t.slice(e,e+r));const s=[];for(let t=0;t<a.length;t++){const r=a[t],n=(r.reduce((e,t)=>e+parseFloat(t.amount),0),r.length,await Q(e,r));if(!n.success)return{success:!1,results:s,error:`Batch ${t+1} failed: ${n.error}`};s.push(n.result),t<a.length-1&&await new Promise(e=>setTimeout(e,3e3))}return{success:!0,results:s}}catch(r){return{success:!1,error:r.message}}},Z={count:0,lastReset:Date.now(),maxBundlesPerSecond:2},Y=async()=>{const e=Date.now();if(e-Z.lastReset>=1e3&&(Z.count=0,Z.lastReset=e),Z.count>=Z.maxBundlesPerSecond){const t=1e3-(e-Z.lastReset);await new Promise(e=>setTimeout(e,t)),Z.count=0,Z.lastReset=Date.now()}Z.count++},ee=async e=>{try{const t=window.tradingServerUrl?.replace(/\/+$/,"")||"",r=await fetch(`${t}/api/transactions/send`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transactions:e})});return(await r.json()).result}catch(t){throw t}},te=async(e,a,n)=>{try{const o=e.map(e=>e.address),i=await(async(e,t,r)=>{try{const a="https://solana.fury.bot",s=await fetch(`${a}/api/wallets/consolidate`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sourceAddresses:e,receiverAddress:t,percentage:r})});if(!s.ok)throw new Error(`HTTP error! Status: ${s.status}`);const n=await s.json();if(!n.success)throw new Error(n.error||"Failed to get partially prepared transactions");return n.transactions}catch(a){throw a}})(o,a.address,n),c=t.fromSecretKey(s.decode(a.privateKey)),l=new Map;e.forEach(e=>{const r=t.fromSecretKey(s.decode(e.privateKey));l.set(r.publicKey.toBase58(),r)});const d=((e,t,a)=>{try{return e.map(e=>{const n=s.decode(e),o=r.deserialize(n),i=o.message,c=[];c.push(a);for(const r of i.staticAccountKeys){const e=r.toBase58();t.has(e)&&c.push(t.get(e))}return o.sign(c),s.encode(o.serialize())})}catch(n){throw n}})(i,l,c),u=(e=>{const t=[];for(let r=0;r<e.length;r+=5){const a=e.slice(r,r+5);t.push({transactions:a})}return t})(d);let y=[];for(let e=0;e<u.length;e++){const t=u[e];await Y();const r=await ee(t.transactions);y.push(r),e<u.length-1&&await new Promise(e=>setTimeout(e,500))}return{success:!0,result:y}}catch(o){return{success:!1,error:o.message}}},re=(e,t,r,a)=>{if(!t.address||!t.privateKey)return{valid:!1,error:"Invalid receiver wallet"};if(!e.length)return{valid:!1,error:"No source wallets"};for(const s of e){if(!s.address||!s.privateKey)return{valid:!1,error:"Invalid source wallet data"};if((a.get(s.address)||0)<=0)return{valid:!1,error:`Source wallet ${s.address.substring(0,6)}... has no balance`}}return isNaN(r)||r<=0||r>100?{valid:!1,error:"Percentage must be between 1 and 100"}:{valid:!0}},ae=async e=>{try{const t=window.tradingServerUrl?.replace(/\/+$/,"")||"",r=await fetch(`${t}/api/transactions/send`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transactions:e})});return(await r.json()).result}catch(t){throw t}},se=async(e,a)=>{try{const n=[{address:a.address,amount:a.amount}],o=await(async(e,t)=>{try{const r="https://solana.fury.bot",a=await fetch(`${r}/api/wallets/mixer`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sender:e,recipients:t})});if(!a.ok)throw new Error(`HTTP error! Status: ${a.status}`);const s=await a.json();if(!s.success)throw new Error(s.error||"Failed to get partially signed transactions");return s.transactions}catch(r){throw r}})(e.address,n),i=t.fromSecretKey(s.decode(e.privateKey)),c=new Map,l=t.fromSecretKey(s.decode(a.privateKey));c.set(l.publicKey.toBase58(),l);const d=((e,t,a)=>{try{return e.map((e,n)=>{const o=s.decode(e),i=r.deserialize(o);if(0===n)i.sign([t]);else if(1===n&&a.size>0){const e=Array.from(a.values())[0];i.sign([e])}else{const e=i.message,r=[];for(const s of e.staticAccountKeys){const e=s.toBase58();e===t.publicKey.toBase58()?r.push(t):a.has(e)&&r.push(a.get(e))}0===r.length&&r.push(t),i.sign(r)}return s.encode(i.serialize())})}catch(n){throw n}})(o,i,c),u=[{transactions:d}];let y=[];for(let e=0;e<u.length;e++){const t=u[e],r=await ae(t.transactions);y.push(r),e<u.length-1&&await new Promise(e=>setTimeout(e,500))}return{success:!0,result:y}}catch(n){return{success:!1,error:n.message}}},ne=(e,t,r)=>{if(!e.address||!e.privateKey)return{valid:!1,error:"Invalid sender wallet"};if(!t.length)return{valid:!1,error:"No recipient wallets"};for(const n of t){if(!n.address||!n.privateKey||!n.amount)return{valid:!1,error:"Invalid recipient wallet data"};if(isNaN(parseFloat(n.amount))||parseFloat(n.amount)<=0)return{valid:!1,error:"Invalid amount: "+n.amount}}const a=t.reduce((e,t)=>e+parseFloat(t.amount),0),s=.01*t.length;return a+s>r?{valid:!1,error:`Insufficient balance. Need at least ${a+s} SOL, but have ${r} SOL`}:{valid:!0}},oe=async(e,t)=>{try{if(0===t.length)return{success:!0,results:[]};const r=[];for(let a=0;a<t.length;a++){const s=t[a],n=await se(e,s);if(!n.success)return{success:!1,results:r,error:`Mixing to recipient ${a+1} (${s.address}) failed: ${n.error}`};r.push(n.result),a<t.length-1&&await new Promise(e=>setTimeout(e,3e3))}return{success:!0,results:r}}catch(r){return{success:!1,error:r.message}}},ie={count:0,lastReset:Date.now(),maxBundlesPerSecond:2},ce=async()=>{const e=Date.now();if(e-ie.lastReset>=1e3&&(ie.count=0,ie.lastReset=e),ie.count>=ie.maxBundlesPerSecond){const t=1e3-(e-ie.lastReset);await new Promise(e=>setTimeout(e,t)),ie.count=0,ie.lastReset=Date.now()}ie.count++},le=async e=>{try{const t=window.tradingServerUrl?.replace(/\/+$/,"")||"",r=await fetch(`${t}/api/transactions/send`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transactions:e})});if(!r.ok)throw new Error(`HTTP error! Status: ${r.status}`);const a=await r.json();if(a.error)throw new Error(a.error.message||"Unknown error from bundle server");return a.result}catch(t){throw t}},de=e=>{const t=.85+.3*Math.random();return Math.floor(200*Math.pow(1.5,e)*t)},ue=e=>{try{return s.decode(e)}catch(t){try{return Buffer.from(e,"base64")}catch(r){throw new Error(`Could not decode transaction: ${r.message}`)}}},ye=async(e,a,n)=>{try{const c=await(async(e,t)=>{try{const r="https://solana.fury.bot",a=t.map(t=>({publicKey:t.publicKey,amount:t.amount||1e9*e.initialBuyAmount})),s=await fetch(`${r}/api/letsbonk/create`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({tokenMetadata:e.tokenMetadata,ownerPublicKey:e.ownerPublicKey,buyerWallets:a,initialBuyAmount:e.initialBuyAmount,type:e.type||e.tokenMetadata.type||"meme"})});if(!s.ok)throw new Error(`HTTP error! Status: ${s.status}`);const n=await s.json();if(!n.success)throw new Error(n.error||"Failed to get partially prepared bonk transactions");return n}catch(r){throw r}})(e,n);if(!c.success||!c.tokenCreation)throw new Error(c.error||"Failed to prepare bonk token creation");const l=t.fromSecretKey(s.decode(a.privateKey)),d=new Map;n.forEach(e=>{d.set(e.publicKey,t.fromSecretKey(s.decode(e.privateKey)))});const u=((e,t)=>{try{const a=ue(e),n=r.deserialize(a),o=t.publicKey.toBase58(),i=n.message.staticAccountKeys,c=[];for(let e=0;e<i.length;e++)if(i[e].toBase58()===o){c.push(t);break}return n.sign(c),s.encode(n.serialize())}catch(a){throw a}})(c.tokenCreation.transaction,l),y=[u,...c.buyerTransactions?(o=c.buyerTransactions,i=d,o.map(e=>{try{const t=i.get(e.publicKey);if(!t)throw new Error(`No keypair found for buyer: ${e.publicKey}`);const a=ue(e.transaction),n=r.deserialize(a);return n.sign([t]),s.encode(n.serialize())}catch(t){throw t}})):[]],p=await(async e=>{let t=0,r=0;for(;t<50&&r<3;){try{return await ce(),{success:!0,result:await le(e)}}catch(a){r++;const e=de(t);await new Promise(t=>setTimeout(t,e))}t++}return{success:!1,error:`Failed to send first bundle after ${t} attempts`}})(y);if(!p.success)return{success:!1,error:p.error||"Failed to send transactions bundle"};const w=1,h=0;return{success:!0,mintAddress:c.tokenCreation.mint,poolId:c.tokenCreation.poolId,result:{totalBundles:1,successCount:w,failureCount:h}}}catch(c){return{success:!1,error:c.message}}var o,i},pe={count:0,lastReset:Date.now(),maxBundlesPerSecond:2},we=async()=>{const e=Date.now();if(e-pe.lastReset>=1e3&&(pe.count=0,pe.lastReset=e),pe.count>=pe.maxBundlesPerSecond){const t=1e3-(e-pe.lastReset);await new Promise(e=>setTimeout(e,t)),pe.count=0,pe.lastReset=Date.now()}pe.count++},he=async e=>{try{const t="https://solana.fury.bot",r=await fetch(`${t}/api/transactions/send`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transactions:e})});if(!r.ok)throw new Error(`HTTP error! Status: ${r.status}`);const a=await r.json();if(a.error)throw new Error(a.error.message||"Unknown error from bundle server");return a.result}catch(t){throw t}},fe=e=>{const t=.85+.3*Math.random();return Math.floor(200*Math.pow(1.5,e)*t)},me=e=>{if(e.match(/^[A-Za-z0-9+/=]+$/)&&e.length%4==0)try{return Buffer.from(e,"base64")}catch(t){}try{return s.decode(e)}catch(t){try{return Buffer.from(e,"base64")}catch(r){throw new Error(`Could not decode transaction: ${r.message}`)}}},ge=async(e,a,n)=>{try{const c=await(async(e,t)=>{try{const r="https://solana.fury.bot",a=t.map(t=>({publicKey:t.publicKey,amount:t.amount||1e9*e.initialBuyAmount})),s=await fetch(`${r}/api/cookmeme/create`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({tokenMetadata:e.tokenMetadata,ownerPublicKey:e.ownerPublicKey,buyerWallets:a,initialBuyAmount:e.initialBuyAmount,tradingTimestamp:e.tradingTimestamp||0,settingsVersion:e.settingsVersion||1})});if(!s.ok)throw new Error(`HTTP error! Status: ${s.status}`);const n=await s.json();if(!n.success)throw new Error(n.error||"Failed to get partially prepared cook transactions");return n}catch(r){throw r}})(e,n);if(!c.success||!c.tokenCreation)throw new Error(c.error||"Failed to prepare cook token creation");const l=t.fromSecretKey(s.decode(a.privateKey)),d=new Map;n.forEach(e=>{d.set(e.publicKey,t.fromSecretKey(s.decode(e.privateKey)))});const u=((e,t)=>{try{const a=me(e),n=r.deserialize(a),o=t.publicKey.toBase58(),i=n.message.staticAccountKeys,c=[];for(let e=0;e<i.length;e++)if(i[e].toBase58()===o){c.push(t);break}return n.sign(c),s.encode(n.serialize())}catch(a){throw a}})(c.tokenCreation.transaction,l),y=[u,...c.buyerTransactions?(o=c.buyerTransactions,i=d,o.map(e=>{try{const t=i.get(e.publicKey);if(!t)throw new Error(`No keypair found for buyer: ${e.publicKey}`);const a=me(e.transaction),n=r.deserialize(a);return n.sign([t]),s.encode(n.serialize())}catch(t){throw t}})):[]],p=await(async e=>{let t=0,r=0;for(;t<50&&r<3;){try{return await we(),{success:!0,result:await he(e)}}catch(a){r++;const e=fe(t);await new Promise(t=>setTimeout(t,e))}t++}return{success:!1,error:`Failed to send first bundle after ${t} attempts`}})(y);if(!p.success)return{success:!1,error:p.error||"Failed to send transactions bundle"};const w=1,h=0;return{success:!0,mintAddress:c.tokenCreation.mint,poolId:c.tokenCreation.poolId,result:{totalBundles:1,successCount:w,failureCount:h}}}catch(c){return{success:!1,error:c.message}}var o,i},be={count:0,lastReset:Date.now(),maxBundlesPerSecond:2},ve=(e,t)=>{try{const a=s.decode(e),n=r.deserialize(a);return n.sign([t]),s.encode(n.serialize())}catch(a){throw a}},Se=(e,t)=>{try{const a=s.decode(e),n=r.deserialize(a);return n.sign(t),s.encode(n.serialize())}catch(a){throw a}},Te=async(e,a,n,o,i,c,l=.05)=>{try{const d=t.fromSecretKey(s.decode(e.privateKey)),u=t.fromSecretKey(s.decode(a.privateKey)),y="auto",p=o>0;let w=[];if(p){if(c<=0)throw new Error("Seller has no tokens to sell");w=await(async(e,t,r,a)=>{try{const s=window.tradingServerUrl?.replace(/\/+$/,"")||"",n=x(),o=n?.transactionFee||"0.005",i=Math.floor(1e9*parseFloat(o)),c=await fetch(`${s}/api/tokens/sell`,{method:"POST",headers:{"Content-Type":"application/json","x-api-key":n?.apiKey||""},body:JSON.stringify({walletAddresses:[e],tokenAddress:t,protocol:a,percentage:r,jitoTipLamports:i})});if(!c.ok)throw new Error(`HTTP error! Status: ${c.status}`);const l=await c.json();if(!l.success)throw new Error(l.error||"Failed to get sell transactions");if(l.bundles&&Array.isArray(l.bundles))return l.bundles.flatMap(e=>Array.isArray(e)?e:e.transactions||[]);if(l.transactions&&Array.isArray(l.transactions))return l.transactions;if(Array.isArray(l))return l;throw new Error("No transactions returned from sell endpoint")}catch(s){throw s}})(e.address,n,o,y)}if(i<=0||i>100)throw new Error("Buy amount must be between 0.001 and 100 SOL");const h=(i+l).toFixed(9),f=await(async(e,t,r)=>{try{const a="https://solana.fury.bot",s=await fetch(`${a}/api/wallets/distribute`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({sender:e,recipients:[{address:t,amount:r}]})});if(!s.ok)throw new Error(`HTTP error! Status: ${s.status}`);const n=await s.json();if(!n.success)throw new Error(n.error||"Failed to get distribution transactions");return n.transactions||[]}catch(a){throw a}})(e.address,a.address,h),m=await(async(e,t,r,a)=>{try{const s=window.tradingServerUrl?.replace(/\/+$/,"")||"",n=x(),o=n?.transactionFee||"0.005",i=Math.floor(1e9*parseFloat(o)),c=await fetch(`${s}/api/tokens/buy`,{method:"POST",headers:{"Content-Type":"application/json","X-API-Key":n?.apiKey||""},body:JSON.stringify({walletAddresses:[e],tokenAddress:t,solAmount:r,protocol:a,jitoTipLamports:i})});if(!c.ok)throw new Error(`HTTP error! Status: ${c.status}`);const l=await c.json();if(!l.success)throw new Error(l.error||"Failed to get buy transactions");if(l.bundles&&Array.isArray(l.bundles))return l.bundles.flatMap(e=>Array.isArray(e)?e:e.transactions||[]);if(l.transactions&&Array.isArray(l.transactions))return l.transactions;if(Array.isArray(l))return l;throw new Error("No transactions returned from buy endpoint")}catch(s){throw s}})(a.address,n,i,y),g=w.map(e=>ve(e,d)),b=f.map(e=>Se(e,[d,u])),v=m.map(e=>{const t=s.decode(e),a=r.deserialize(t),n=d.publicKey.toBase58();return a.message.staticAccountKeys.some(e=>e.toBase58()===n)?Se(e,[d,u]):ve(e,u)}),S=[...g,...b,...v];await(async()=>{const e=Date.now();if(e-be.lastReset>=1e3&&(be.count=0,be.lastReset=e),be.count>=be.maxBundlesPerSecond){const t=1e3-(e-be.lastReset);await new Promise(e=>setTimeout(e,t)),be.count=0,be.lastReset=Date.now()}be.count++})();return{success:!0,result:{bundleResult:await(async e=>{try{const t=window.tradingServerUrl?.replace(/\/+$/,"")||"",r=await fetch(`${t}/api/transactions/send`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({transactions:e})});return(await r.json()).result}catch(t){throw t}})(S),transactionCount:S.length,breakdown:{sellTransactions:g.length,distributionTransactions:b.length,buyTransactions:v.length},amounts:{tokensSold:p?c*(o/100):0,solUsedForBuy:i,distributionAmount:parseFloat(h),extraDistributionSol:l},protocol:y,operationType:p?"sell-distribute-buy":"distribute-buy"}}}catch(d){return{success:!1,error:d.message}}},ke=(e,t,r,a,s,n)=>e.address&&e.privateKey?t.address&&t.privateKey?r?isNaN(a)||a<0||a>100?{valid:!1,error:"Sell percentage must be between 0 and 100"}:isNaN(s)||s<=0||s>100?{valid:!1,error:"Buy amount must be between 0.001 and 100 SOL"}:a>0&&(!n||n<=0)?{valid:!1,error:"Seller has no tokens to sell"}:{valid:!0}:{valid:!1,error:"Token address is required"}:{valid:!1,error:"Invalid buyer wallet"}:{valid:!1,error:"Invalid seller wallet"};export{l as A,i as B,H as C,J as D,A as E,j as F,O as G,R as H,N as I,I as J,z as K,W as L,L as M,q as U,$ as a,k as b,S as c,D as d,B as e,C as f,U as g,E as h,T as i,d as j,P as k,K as l,x as m,ye as n,ge as o,Te as p,_ as q,G as r,F as s,X as t,re as u,ke as v,te as w,ne as x,oe as y,M as z};
